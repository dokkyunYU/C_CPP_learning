for (char j : arr) 같은 형식의 반복문을 range-based for loop이라고 부르는데

C++11에서 추가된 문법이며 기존 for loop과 동일하지는 않습니다.

특히 arr이 있는 자리에 들어가는 것은

배열, { } 괄호를 이용한 초기화리스트(init-list), 반복자(iterator)를 제공하는 객체(std의 vector, string 등) 중 하나여야 합니다.

컴파일러가 begin 함수를 찾는 건 이 arr이라는 게 배열이나 초기화리스트는 확실히 아니니 반복자를 얻으려고 하는 것이고,

맨 앞 원소를 가리키는 반복자를 주는 함수가 begin이기 때문입니다.

동적 할당으로 얻은 메모리는 인덱스와 포인터 연산은 지원되는 건 배열과 비슷하나 이 문법에는 사용할 수 없습니다.






범위기반 for문은 a의 복사형을 받기 때문에, 컨테이너 (혹은 배열) 의 내용물을 변경한다면 변경되지 않습니다.

그러나 인수를 참조형(타입& 변수명)으로 사용한다면, 변경할 수 있다.

함수와 마찬가지로, 참조형으로 원소를 받으면, 주소를 넘기는 것이기 때문에 용량이 큰 컨테이너나 사용자 정의 타입에 대해 효과적이다.

만약 수정을 원하지 않을 경우 상수로 바꾸시면 됩니다. (const int& i 같이)



또한 컨테이너 타입 ( vector, list ...) 에 사용 가능합니다.


( 다음에 auto keyword 에 대한 설명글도 작성이 되어있습니다. )





<출력>



역시나 vector의 원소들에 대한 값 변경을 원하신다면 참조형으로 받아야 합니다.

<심화 내용>



범위 기반 for 문을 사용하려면 begin 함수와 end 함수가 구현이 돼있어야 합니다.

기본 컨테이너들 (vector, list...) 에 대해선 이미 구현이 돼있지만 사용자 정의 타입에서는 구현을 해주셔야 사용 가능합니다.





<사용자 정의타입의 링크드 리스트에 범위 기반 for문을 적용하는 모습>



기본적으로 begin, end, 그리고 증가 연산자를 구현하여야 합니다.

만약 사용자 정의 타입에 거꾸로 출력을 원하신다면, 래퍼를 만들어주시거나 boost 라이브러리를 이용해야 합니다.

















reversion_wrapper에 대한 부가설명을 하자면 
일단 reserve에 들어가면 reserve 함수는 reversion_wrapper의 생성자를 호출합니다.

(이때 초기화 리스트를 사용합니다. 이유는 함수의 return 형에 중괄호가 돼있기 때문에)

그리고 reversion_wrapper는 T& 형 타입의 변수를 뱉어 냅니다.(이때 T형은 initializer_list<int> 형입니다)